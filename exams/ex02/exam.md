# Exam 2

## Question 1

Explain the steps and process of compiling one language to another. 

+ Step 1: Choose the compile and target langauge
+ Step 2: ...
+ (add more steps as needed)

## Question 2

What makes a program secure?
What makes a language secure?

## Question 3

Is assembly (any flavor, eg: x86, MIPS, etc) reflective? Justify.

## Question 4

In either Befunge or INTERCAL, write a program that reads in a list of integers, and prints out the max, min, and sum of the list.
For both languages, assume the list ends with a zero.

## Question 5

Implement question 4 in SQLite, with a catch -- the list might be any length, but you should still stop at 0.
Assume you are given a database `input.db` generated by:
```sql
CREATE TABLE input (
    id   INTEGER PRIMARY KEY,
    list INTEGER
);
INSERT INTO input (list) VALUES
    (42), -- or replace with any list of integers
    (69),
    (420), -- the maximum
    (3),   -- the minimum
    (0), -- list operations should stop here!
    (2), -- should not be included
    (5), -- same
    (0),
    (1)
;
-- this specific list should return: 420 | 3 | 534
-- 534 = 42 + 69 + 420 + 3
```
Assume your statement is written in a file like `q5.sql` and is executed like `sqlite3 input.db < q5.sql`.

One way to solve this is by using a subquery to compute which row to stop at (or, to find the `id` column value where the `list` column value gives the first zero).
Then you can use that subquery inside of a `WHERE` condition.

Then, answer the following (more important) question.
Which aspects were harder, and which were easier, in your SQLite implementation compared to Befunge or INTERCAL? 

## Bonus

Contest the exam 1 bonus queston and explain why Interstellar was a horrible movie.
